// Generated by CoffeeScript 1.11.1
var Builder, NamedFunction, Shape, TypeBuilder, assertType, bind, define, emptyFunction, frozen, hasKeys, isDev, isType, setKind, setType, sync;

frozen = require("Property").frozen;

NamedFunction = require("NamedFunction");

emptyFunction = require("emptyFunction");

assertType = require("assertType");

Builder = require("Builder");

setKind = require("setKind");

setType = require("setType");

hasKeys = require("hasKeys");

isType = require("isType");

define = require("define");

Shape = require("Shape");

isDev = require("isDev");

sync = require("sync");

bind = require("bind");

TypeBuilder = NamedFunction("TypeBuilder", function(name) {
  var self;
  self = Builder(name);
  self._phases.args = [];
  return setType(self, TypeBuilder);
});

module.exports = setKind(TypeBuilder, Builder);

define(TypeBuilder, {
  _stringifyTypes: function(types) {
    return JSON.stringify(types);
  }
});

define(TypeBuilder.prototype, {
  defineArgs: function(args) {
    var argDefaults, argNames, argTypes, requiredTypes, validateArgs;
    assertType(args, Object);
    if (this._hasArgs) {
      throw Error("'defineArgs' must only be called once!");
    } else {
      frozen.define(this, "_hasArgs", {
        value: true
      });
    }
    argNames = [];
    argTypes = {};
    argDefaults = {};
    requiredTypes = {};
    sync.each(args, function(arg, name) {
      var argType;
      argNames.push(name);
      if (!isType(arg, Object)) {
        argTypes[name] = arg;
        return;
      }
      if (arg["default"] !== void 0) {
        argDefaults[name] = arg["default"];
      }
      if (argType = arg.type) {
        if (isType(argType, Object)) {
          argType = Shape(argType);
        }
        if (arg.required) {
          requiredTypes[name] = true;
        }
        return argTypes[name] = argType;
      }
    });
    this._phases.args.push(validateArgs = function(args) {
      var arg, argType, index, j, len, name;
      for (index = j = 0, len = argNames.length; j < len; index = ++j) {
        name = argNames[index];
        arg = args[index];
        if (arg === void 0) {
          if (argDefaults[name] !== void 0) {
            args[index] = arg = argDefaults[name];
          } else if (!requiredTypes[name]) {
            continue;
          }
        }
        if (isDev && (argType = argTypes[name])) {
          argType && assertType(arg, argType, "args[" + index + "]");
        }
      }
      return args;
    });
    this.didBuild(function(type) {
      if (hasKeys(argTypes)) {
        type.argTypes = argTypes;
        frozen.define(argTypes, "toString", {
          value: function() {
            return TypeBuilder._stringifyTypes(argTypes);
          },
          enumerable: false
        });
      }
      if (hasKeys(argDefaults)) {
        return type.argDefaults = argDefaults;
      }
    });
  },
  initArgs: function(func) {
    var initArgs;
    assertType(func, Function);
    initArgs = function(args) {
      func.call(this, args);
      return args;
    };
    isDev && (initArgs = bind.toString(func, initArgs));
    this._phases.args.push(initArgs);
  },
  replaceArgs: function(replaceArgs) {
    assertType(replaceArgs, Function);
    if (isDev) {
      this._phases.args.push(bind.toString(replaceArgs, function(args) {
        args = replaceArgs.call(this, args);
        if (args && typeof args.length === "number") {
          return args;
        }
        throw TypeError("Must return an array-like object!");
      }));
      return;
    }
    this._phases.args.push(replaceArgs);
  },
  defineOptions: function(optionConfigs) {
    var optionDefaults, optionNames, optionTypes, requiredTypes, validateOptions;
    assertType(optionConfigs, Object);
    if (this._hasOptions) {
      throw Error("'defineOptions' must only be called once!");
    } else {
      frozen.define(this, "_hasOptions", {
        value: true
      });
    }
    optionNames = [];
    optionTypes = {};
    optionDefaults = {};
    requiredTypes = {};
    sync.each(optionConfigs, function(option, name) {
      var optionType;
      optionNames.push(name);
      if (!isType(option, Object)) {
        optionTypes[name] = option;
        return;
      }
      if (option["default"] !== void 0) {
        optionDefaults[name] = option["default"];
      }
      if (optionType = option.type) {
        if (isType(optionType, Object)) {
          optionType = Shape(optionType);
        }
        if (option.required) {
          requiredTypes[name] = true;
        }
        return optionTypes[name] = optionType;
      }
    });
    this._phases.args.push(validateOptions = function(args) {
      var j, len, name, option, optionType, options;
      if (!(options = args[0])) {
        args[0] = options = {};
      }
      assertType(options, Object, "options");
      for (j = 0, len = optionNames.length; j < len; j++) {
        name = optionNames[j];
        option = options[name];
        if (option === void 0) {
          if (optionDefaults[name] !== void 0) {
            options[name] = option = optionDefaults[name];
          } else if (!requiredTypes[name]) {
            continue;
          }
        }
        if (isDev && (optionType = optionTypes[name])) {
          optionType && assertType(option, optionType, "options." + name);
        }
      }
      return args;
    });
    this.didBuild(function(type) {
      if (hasKeys(optionTypes)) {
        type.optionTypes = optionTypes;
        frozen.define(optionTypes, "toString", {
          value: function() {
            return TypeBuilder._stringifyTypes(optionTypes);
          },
          enumerable: false
        });
      }
      if (hasKeys(optionDefaults)) {
        return type.optionDefaults = optionDefaults;
      }
    });
  }
});

define(TypeBuilder.prototype, {
  __createArgBuilder: function() {
    var argPhases, buildArgs;
    argPhases = this._phases.args;
    if (argPhases.length === 0) {
      return emptyFunction.thatReturnsArgument;
    }
    return buildArgs = function(initialArgs, context) {
      var arg, args, i, j, k, len, len1, phase;
      args = new Array(initialArgs.length);
      for (i = j = 0, len = initialArgs.length; j < len; i = ++j) {
        arg = initialArgs[i];
        args[i] = arg;
      }
      for (k = 0, len1 = argPhases.length; k < len1; k++) {
        phase = argPhases[k];
        args = phase.call(context, args);
      }
      return args;
    };
  }
});
